package cmd

import (
	"fmt"

	"github.com/go-errors/errors"
	"github.com/ory-am/common/rand/sequence"
	"github.com/ory-am/fosite"
	"github.com/ory-am/fosite/handler/core"
	"github.com/ory-am/fosite/handler/core/explicit"
	"github.com/ory-am/fosite/handler/core/implicit"
	"github.com/ory-am/fosite/handler/core/refresh"
	"github.com/ory-am/fosite/handler/core/strategy"
	"github.com/ory-am/fosite/handler/oidc"
	oidcstrategy "github.com/ory-am/fosite/handler/oidc/strategy"
	"github.com/ory-am/fosite/hash"
	"github.com/ory-am/fosite/token/hmac"
	"github.com/ory-am/fosite/token/jwt"
	"github.com/ory-am/hydra/client"
	"github.com/ory-am/hydra/internal"
	"github.com/ory-am/hydra/key"
	"github.com/ory-am/ladon"
	"github.com/ory-am/ladon/memory"
)

type fositeStorer interface {
	core.AccessTokenStorage
	fosite.Storage
	explicit.AuthorizeCodeGrantStorage
	refresh.RefreshTokenGrantStorage
	implicit.ImplicitGrantStorage
	oidc.OpenIDConnectRequestStorage
}

func newIdStrategy(c *configuration, k key.Manager) oidc.OpenIDConnectTokenStrategy {
	key, err := k.GetAsymmetricKey("openid")
	if err != nil {
		fatal("Could not retrieve openid keypar because %s", err)
	}

	return &oidcstrategy.DefaultStrategy{
		RS256JWTStrategy: &jwt.RS256JWTStrategy{
			PrivateKey: key.Private,
			PublicKey:  key.Public,
		},
	}
}

func newKeyManager(c *configuration) key.Manager {
	if c.ClusterURL == "" {
	}

	km := &key.MemoryManager{
		AsymmetricKeys: map[string]*key.AsymmetricKey{},
		SymmetricKeys:  map[string]*key.SymmetricKey{},
		Strategy: &key.DefaultKeyStrategy{
			AsymmetricKeyStrategy: &key.RSAPEMStrategy{},
			SymmetricKeyStrategy:  &key.SHAStrategy{},
		},
	}

	_, err := km.CreateAsymmetricKey("openid")
	if err != nil {
		fatal("Could not create assymetric key pair")
	}

	return km
}

func newHasher(c *configuration) hash.Hasher {
	return &hash.BCrypt{
		WorkFactor: 11,
	}
}

func newFositeStore(c *configuration, cl client.Manager) fositeStorer {
	if c.ClusterURL == "" {
	}

	return &internal.FositeMemoryStore{
		Manager:        cl,
		AuthorizeCodes: make(map[string]fosite.Requester),
		IDSessions:     make(map[string]fosite.Requester),
		AccessTokens:   make(map[string]fosite.Requester),
		Implicit:       make(map[string]fosite.Requester),
		RefreshTokens:  make(map[string]fosite.Requester),
	}
}

func newLadonStore(c *configuration) ladon.Manager {
	if c.ClusterURL == "" {
	}

	return &memory.Manager{
		Policies: make(map[string]ladon.Policy),
	}

}

func newClientStore(c *configuration, hash hash.Hasher) client.Manager {
	if c.ClusterURL == "" {
	}

	return &client.MemoryManager{
		Clients: make(map[string]*fosite.DefaultClient),
		Hasher:  hash,
	}
}

func newHmacStrategy(c *configuration) *strategy.HMACSHAStrategy {
	if c.ClusterURL == "" {
	}

	return &strategy.HMACSHAStrategy{
		Enigma: &hmac.HMACStrategy{
			GlobalSecret: c.GetSystemSecret(),
		},
	}

}

func createAdminIfNotExists(clientStore client.Manager, ladonStore ladon.Manager, saveCredentials bool) error {
	clients, err := clientStore.GetClients()
	if err != nil {
		return errors.Errorf("Could not retrieve initial clients list because %s", err.Error())
	} else if len(clients) != 0 {
		return nil
	}

	secret, err := sequence.RuneSequence(32, secretCharSet)
	if err != nil {
		return errors.Errorf("Could not generate a secure secret because %s", err.Error())
	}

	adminClient := &fosite.DefaultClient{
		Name:          "This client is generated by hydra and is granted all of hydra's administrative privileges.",
		GrantTypes:    []string{"client_credentials"},
		ResponseTypes: []string{"token"},
		Secret:        []byte(string(secret)),
	}

	if err = clientStore.CreateClient(adminClient); err != nil {
		return errors.Errorf("Could not create initial admin because %s", err.Error())
	}

	if err = ladonStore.Create(&ladon.DefaultPolicy{
		Description: "This is a policy created by hydra and issued to the first client. It grants all of hydra's administrative privileges to the client and enables the client_credentials response type.",
		Subjects:    []string{adminClient.GetID()},
		Effect:      ladon.AllowAccess,
		Resources:   []string{"rn:hydra:<.*>"},
		Actions:     []string{"<.*>"},
	}); err != nil {
		return errors.Errorf("Could not create admin policy because %s", err.Error())
	}

	if saveCredentials {
		config.ClientID = adminClient.ID
		config.ClientSecret = string(secret)
		config.Save()
	}

	fmt.Printf(`┬┴┬┴┬┴┬┴┬┴┬┴┤   ├┬┴┬┴┬┴┬┴┬┴┬┴┬┴
┬┴┬┴┬┴┬┴┬┴┬┴┤(._├┬┴┬┴┬┴┬┴┬┴┬┴┬┴
I could not find any OAuth2 clients. I will create an
administrative OAuth2 client which you must use to manage
hydra. The client id and client secret will only be
shown this once. Keep them in a very safe place!

client_id: %s
client_secret: %s

Warning!
We recommend to delete this account once you have set up
all you need to do and grant only real users with two factor authentication administrative privileges.
Please be aware that this account is allowed to do anything, including the creation and deletion of admins.

Once you run a CLI client command, you will be prompted to provide these credentials.

┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴
┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┴
`, adminClient.GetID(), string(secret))

	return nil
}
